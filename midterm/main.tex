\documentclass[10pt,a4paper]{article}
\usepackage[a4paper,margin=0.12in]{geometry}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{amsmath,amssymb}
\usepackage{array}
\usepackage{colortbl}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\pagestyle{empty}

% ── COLORS ──────────────────────────────────────
\definecolor{cblue}{HTML}{1E40AF}
\definecolor{cgreen}{HTML}{166534}
\definecolor{corange}{HTML}{C2410C}
\definecolor{cpurple}{HTML}{7E22CE}
\definecolor{cred}{HTML}{B91C1C}
\definecolor{cteal}{HTML}{0F766E}
\definecolor{cbg}{HTML}{EDF2FF}
\definecolor{rulecolor}{HTML}{CBD5E1}

% ── SECTION HEADER ──
\newcommand{\sect}[2]{%
  \vspace{5pt}%
  {\noindent\fontsize{8}{9.2}\selectfont\sffamily\bfseries\textcolor{#1}{\rule{2pt}{8pt}\;\,#2}\par\nobreak}%
  \vspace{-1pt}\noindent{\color{#1}\rule{\columnwidth}{0.5pt}}\vspace{2pt}\par\nobreak%
}

% ── SUB-HEADER ──
\newcommand{\sub}[1]{%
  \vspace{2.5pt}{\noindent\fontsize{6}{7}\selectfont\sffamily\bfseries #1}\vspace{1pt}\par\nobreak%
}

% ── CODE (monospace) ──
\newcommand{\cd}[1]{{\fontsize{5.5}{6.5}\selectfont\texttt{#1}}}

% ── Arrows and markers ──
\newcommand{\ra}{\,{\fontsize{4.8}{4.8}\selectfont$\boldsymbol{\rightarrow}$}\,}
\newcommand{\W}{\textcolor{cred}{\fontsize{5.8}{5.8}\selectfont$\blacktriangleright$}\,}

% ── Tight itemize ──
\setlist[itemize]{leftmargin=7pt, itemsep=0pt, parsep=0pt, topsep=0.5pt, partopsep=0pt, label={\scriptsize$\bullet$}}

% ── Table defaults ──
\setlength{\tabcolsep}{3pt}
\renewcommand{\arraystretch}{1.1}

\begin{document}

% ═══════════════════════════════════════════════════
%  PAGE 1 — DATA FUNDAMENTALS
% ═══════════════════════════════════════════════════

\fontsize{6}{7.2}\selectfont
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.3pt}
\setlength{\columnsep}{5pt}
\setlength{\columnseprule}{0.15pt}
\def\columnseprulecolor{\color{rulecolor}}

\hfill{\fontsize{6}{7}\selectfont\textbf{Yuer Tang} \enspace 005959967}\par\vspace{1pt}

\begin{multicols}{3}

% ─────────────────────────────────────────────────
\sect{cblue}{DATA TYPES \& STRUCTURES}
% ─────────────────────────────────────────────────

\sub{6 Atomic Types (coercion order)}
\cd{logical} $<$ \cd{integer} $<$ \cd{double} $<$ \cd{character} $<$ \cd{complex} $<$ \cd{raw}

\sub{typeof() vs class() vs mode()}
\begin{tabular}{@{}l|l|l|l@{}}
\rowcolor{cbg}\textbf{Object} & \cd{typeof} & \cd{class} & \cd{mode}\\
\cd{TRUE} & \cd{"logical"} & \cd{"logical"} & \cd{"logical"}\\
\rowcolor{cbg!40}\cd{1L} & \cd{"integer"} & \cd{"integer"} & \cd{"numeric"}\\
\cd{3.14} & \cd{"double"} & \cd{"numeric"} & \cd{"numeric"}\\
\rowcolor{cbg!40}\cd{"hi"} & \cd{"character"} & \cd{"character"} & \cd{"character"}\\
\cd{1:3} & \cd{"integer"} & \cd{"integer"} & \cd{"numeric"}\\
\rowcolor{cbg!40}\cd{c(1,2)} & \cd{"double"} & \cd{"numeric"} & \cd{"numeric"}\\
\cd{list()} & \cd{"list"} & \cd{"list"} & \cd{"list"}\\
\rowcolor{cbg!40}\cd{data.frame()} & \cd{"list"} & \cd{"data.frame"} & \cd{"list"}\\
\cd{factor("a")} & \cd{"integer"} & \cd{"factor"} & \cd{"numeric"}\\
\rowcolor{cbg!40}\cd{function(){}} & \cd{"closure"} & \cd{"function"} & \cd{"function"}\\
\cd{NULL} & \cd{"NULL"} & \cd{"NULL"} & \cd{"NULL"}\\
\rowcolor{cbg!40}\cd{NA} & \cd{"logical"} & \cd{"logical"} & \cd{"logical"}\\
\end{tabular}

\vspace{1pt}
\W \cd{is.numeric(x)}\ra \cd{TRUE} for \textbf{both} integer and double!\\
\cd{is.double(1L)}\ra \cd{FALSE}. \cd{is.numeric(1L)}\ra \cd{TRUE}.

\sub{Key Structures}
\textbf{Matrix:} atomic vector + \cd{dim} attr. Filled \textbf{column-wise}.\\
\cd{attr(M,"dim") <- c(2,5)} turns length-10 vec into $2{\times}5$ matrix.\\
\cd{attr(M,"dim") <- NULL}\ra back to plain vector.\\
\cd{class(M)}\ra \cd{c("matrix","array")} when dim set.\\
\textbf{Array:} atomic vector with \cd{dim} length $>2$.\\
\textbf{Data frame:} \cd{typeof}=\cd{"list"}, \cd{class}=\cd{"data.frame"}.\\
\cd{attributes(df)}\ra list with \cd{names}, \cd{class}, \cd{row.names}.\\
\textbf{Attributes:} \cd{attr(x,"info")<-"..."} sets metadata.\\
\cd{attributes(x)}\ra full list. \cd{attr(x,"dim")}\ra get one.

\sub{Factors}
Integer vector with \cd{levels} + \cd{class} attributes.\\
Levels sorted \textbf{alphabetically}: \cd{factor(c("M","F","F"))}\ra levels \cd{c("F","M")}.\\
\cd{as.integer(factor(c("M","F","F")))}\ra \cd{c(2,1,1)}.\\
\W Assigning value not in levels\ra becomes \cd{NA} with warning.\\
\W \textbf{Numeric factor trap:}\\
\cd{as.numeric(factor(c(0,1,10,5)))}\ra \cd{c(1,2,4,3)} (indices!)\\
\textbf{Fix:} \cd{as.numeric(as.character(x\_fac))}

\sub{identical() vs ==}
\cd{==} is vectorized, \cd{NA} propagates. \cd{identical()} returns single T/F.\\
\cd{identical(NA, NA)}\ra \cd{TRUE}. \cd{NA == NA}\ra \cd{NA}.\\
\cd{identical(1, 1L)}\ra \cd{FALSE} (type matters!). \cd{identical(1L, 1L)}\ra \cd{TRUE}.\\
\cd{all.equal(1, 1L)}\ra \cd{TRUE} (near-equality, ignores type).\\
\cd{all.equal(0.1+0.2, 0.3)}\ra \cd{TRUE}. \cd{0.1+0.2 == 0.3}\ra \cd{FALSE} (float!).

\sub{Type checking \& conversion}
\cd{is.numeric()}\ra TRUE for int AND double. \cd{is.atomic()}\ra TRUE for vec.\\
\cd{as.integer(3.9)}\ra \cd{3} (truncates). \cd{as.double(TRUE)}\ra \cd{1}.\\
\cd{as.character(123)}\ra \cd{"123"}. \cd{as.numeric("3.14")}\ra \cd{3.14}.\\
\cd{is.vector(list())}\ra \cd{TRUE}. \cd{is.atomic(list())}\ra \cd{FALSE}.\\
\cd{unlist(list(1,c(2,3)))}\ra \cd{c(1,2,3)}.

% ─────────────────────────────────────────────────
\sect{cblue}{COERCION \& SPECIAL VALUES}
% ─────────────────────────────────────────────────

\sub{Combining different types with c()}
\cd{c(TRUE,1L,2.5)}\ra double \cd{c(1.0,1.0,2.5)}\\
\cd{c(TRUE,1,"a")}\ra character \cd{c("TRUE","1","a")}\\
\cd{c(FALSE,1L)}\ra integer \cd{c(0L,1L)}

\sub{Implicit coercion}
\cd{TRUE}\ra\cd{1}, \cd{FALSE}\ra\cd{0} in math.\\
\cd{sum(c(T,F,T))}\ra\cd{2}. \cd{mean(c(T,F,T))}\ra\cd{0.667}.

\sub{as.logical() rules}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Input} & \textbf{Result}\\
\cd{as.logical(0)} & \cd{FALSE}\\
\rowcolor{cbg!40}\cd{as.logical(1)} & \cd{TRUE}\\
\cd{as.logical(-1)} & \cd{TRUE} (any nonzero$\ne$NaN)\\
\rowcolor{cbg!40}\cd{as.logical(NaN)} & \cd{NA}\\
\cd{as.logical("TRUE"/"true"/"T")} & \cd{TRUE}\\
\rowcolor{cbg!40}\cd{as.logical("False"/"false"/"F")} & \cd{FALSE}\\
\cd{as.logical("t"/"1"/"0")} & \cd{NA}\\
\end{tabular}

\vspace{1pt}
Accepted: \cd{"TRUE","True","true","T","FALSE","False","false","F"} only.\\
\W \cd{as.logical(c("0",1))}\ra all coerced to \textbf{char} first\ra all \cd{NA}.\\
\cd{as.numeric("dog")}\ra \cd{NA} with warning.\\
\cd{as.integer(TRUE)}\ra \cd{1L}. \cd{as.integer(FALSE)}\ra \cd{0L}.\\
\cd{as.character(TRUE)}\ra \cd{"TRUE"}. \cd{as.character(1.5)}\ra \cd{"1.5"}.

\sub{Coercion in matrix/data.frame}
Matrix: all elements same type (coerced). \cd{matrix(c(1,"a"))}\ra all char.\\
Data frame: each column can be different type (list of columns).\\
\cd{cbind()} on mixed types\ra coerces to most general (matrix).\\
\cd{data.frame(x=1:3, y=c("a","b","c"))}\ra preserves types.

\sub{Special values: NA, NULL, NaN, Inf}
\begin{tabular}{@{}l|p{4.2em}|p{4.2em}|p{3.5em}|p{3.2em}@{}}
\rowcolor{cbg} & \textbf{NA} & \textbf{NULL} & \textbf{NaN} & \textbf{Inf}\\
\textbf{Meaning} & Missing & Empty & 0/0 & $\infty$\\
\rowcolor{cbg!40}\cd{typeof} & \cd{"logical"} & \cd{"NULL"} & \cd{"double"} & \cd{"double"}\\
\textbf{In c()} & Kept & Dropped & Kept & Kept\\
\rowcolor{cbg!40}\cd{length} & \cd{1} & \cd{0} & \cd{1} & \cd{1}\\
\cd{is.na()} & \cd{TRUE} & \cd{lgcl(0)} & \cd{TRUE} & \cd{FALSE}\\
\rowcolor{cbg!40}\cd{is.null()} & \cd{FALSE} & \cd{TRUE} & \cd{FALSE} & \cd{FALSE}\\
\cd{is.finite()} & \cd{FALSE} & --- & \cd{FALSE} & \cd{FALSE}\\
\end{tabular}

\sub{NA --- Missing / Unknown}
\cd{NA == NA}\ra \cd{NA} (must use \cd{is.na()}).\\
NA in math: \cd{NA + 1}\ra \cd{NA}. \cd{NA * 0}\ra \cd{NA} (not 0!).\\
\cd{NA \& FALSE}\ra \cd{FALSE}. \cd{NA | TRUE}\ra \cd{TRUE}. (determined!)\\
Typed: \cd{NA\_integer\_}, \cd{NA\_real\_}, \cd{NA\_character\_}, \cd{NA\_complex\_}.\\
NA in vector does NOT change vector's type.\\
\cd{complete.cases(df)}\ra logical, rows with no NA.\\
\cd{na.omit(df)}\ra remove rows with any NA.\\
\cd{is.na(x) <- 3}\ra sets \cd{x[3]} to NA.

\sub{NULL --- Empty / Nonexistent}
\cd{c(4,5,NULL,3)}\ra \cd{c(4,5,3)} (NULL silently dropped!).\\
\cd{length(NULL)}\ra \cd{0}. \cd{NULL + 1}\ra \cd{numeric(0)}.\\
\cd{NULL == NULL}\ra \cd{logical(0)} (not TRUE!). \cd{is.logical(NULL)}\ra \cd{FALSE}.\\
Remove list elements: \cd{l\$x <- NULL}. Default arg: \cd{f(x=NULL)}.

\sub{NaN and Inf}
\cd{0/0}\ra \cd{NaN}. \cd{1/0}\ra \cd{Inf}. \cd{-1/0}\ra \cd{-Inf}. \cd{log(0)}\ra \cd{-Inf}.\\
\cd{Inf - Inf}\ra \cd{NaN}. \cd{Inf + Inf}\ra \cd{Inf}. \cd{Inf * 0}\ra \cd{NaN}.\\
\cd{is.nan(NaN)}\ra \cd{TRUE}. \cd{is.na(NaN)}\ra \cd{TRUE} (NaN is also NA!).\\
\cd{is.infinite(Inf)}\ra \cd{TRUE}. \cd{max(c(1,Inf))}\ra \cd{Inf}.\\
\cd{NaN > 1}\ra \cd{NA}. \cd{Inf > 1e308}\ra \cd{TRUE}.

% ─────────────────────────────────────────────────
\sect{cblue}{OPERATORS, RECYCLING \& PRECEDENCE}
% ─────────────────────────────────────────────────

\sub{Element-wise operators (all recycle)}
\cd{+\; -\; *\; /\; \^{}}\quad \cd{\%\%} (modulo)\quad \cd{\%/\%} (integer div)\\
\cd{5 \%\% 3}\ra \cd{2}. \cd{5 \%/\% 3}\ra \cd{1}. \cd{(-7) \%\% 3}\ra \cd{2} (always $\ge 0$).\\
\cd{c(10,20,30) * c(1,2,3)}\ra \cd{c(10,40,90)}.

\sub{Math functions (vectorized)}
\cd{abs()}, \cd{sqrt()}, \cd{ceiling()}, \cd{floor()}, \cd{round(x,n)}, \cd{trunc()},\\
\cd{log()}, \cd{log2()}, \cd{log10()}, \cd{exp()}, \cd{sign()}.\\
\W \cd{round(2.5)}\ra \cd{2} (banker's rounding! rounds to \textbf{even}).\\
\cd{round(3.5)}\ra \cd{4}. \cd{round(0.5)}\ra \cd{0}. \cd{round(1.5)}\ra \cd{2}.

\sub{Aggregation functions}
\cd{sum()}, \cd{prod()}, \cd{min()}, \cd{max()}, \cd{range()}, \cd{mean()}, \cd{median()},\\
\cd{var()}, \cd{sd()}, \cd{length()}, \cd{nchar()}.\\
\W All return \cd{NA} if input has NA! Fix: \cd{na.rm=TRUE}.\\
Cumulative: \cd{cumsum()}, \cd{cumprod()}, \cd{cummax()}, \cd{cummin()}.

\sub{Set operations on vectors}
\cd{union(x,y)}, \cd{intersect(x,y)}, \cd{setdiff(x,y)}, \cd{setequal(x,y)}.\\
\cd{\%in\%}: logical, vectorized on LEFT only.\\
\cd{c(1,2,3) \%in\% c(2,4)}\ra \cd{c(F,T,F)}.

\sub{Recycling}
Shorter vector \textbf{repeated} to match longer.\\
\W Warning only if longer length NOT multiple of shorter.\\
\cd{c(1,2,3)+c(100,200,300,400,500,600)}\ra \cd{c(101,202,303,401,502,603)} (no warn)\\
\cd{c(1,2,3)+c(100,200,300,400,500)}\ra \cd{c(101,202,303,401,502)} (\textbf{warning})\\
Scalar recycling: \cd{x * 2} recycles 2. No warning.\\
Matrix recycling: \textbf{column-wise} (down col 1, then col 2...).\\
Row-wise trick: \cd{t(t(M) + x)}.\\
Logical recycling: \cd{c(T,F)} recycles for every-other selection.\\
\cd{cbind}/\cd{rbind} recycle shorter to match longer.

\sub{Logical operators}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\textbf{Vectorized} & \textbf{Non-vectorized} & \textbf{Use in}\\
\cd{|} (OR), \cd{\&} (AND) & \cd{||}, \cd{\&\&} & \cd{if()} only\\
Returns \textbf{vector} & Returns \textbf{single} value & Length-1 req'd\\
\end{tabular}

\vspace{1pt}
\cd{||}/\cd{\&\&}: length$>$1\ra \textbf{ERROR} (R$\ge$4.3).\\
\cd{==, !=, <, >, <=, >=} (vectorized, recycling).

\sub{Short-circuit evaluation}
\cd{FALSE \&\& y}\ra \cd{FALSE} (y not evaluated).
\cd{TRUE || y}\ra \cd{TRUE} (y not evaluated).\\
\cd{FALSE || y}\ra evaluates y\ra error if length$>$1.
\cd{TRUE \&\& y}\ra same.

\sub{NA logic}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg} & \cd{TRUE} & \cd{FALSE}\\
\cd{\_\_ | NA} & \cd{TRUE} & \cd{NA}\\
\rowcolor{cbg!40}\cd{\_\_ \& NA} & \cd{NA} & \cd{FALSE}\\
\end{tabular}

Rule: if result determined without NA, R returns it.\\
\cd{xor(T,T)}\ra\cd{F}. \cd{xor(T,F)}\ra\cd{T}. \cd{!NA}\ra\cd{NA}.\\
\cd{any(logical(0))}\ra\cd{FALSE}. \cd{all(logical(0))}\ra\cd{TRUE}.\\
\cd{"10" < "2"}\ra\cd{TRUE} (alphabetical!). \cd{"a" < "A"}\ra\cd{TRUE}.

\sub{Operator precedence (high to low)}
\cd{\^{}} $>$ unary \cd{-/+} $>$ \cd{\%\%/\%/\%*\%/\%in\%} $>$ \cd{*/\!/} $>$ \cd{+/-} $>$ \cd{< > <= >= == !=} $>$ \cd{!} $>$ \cd{\&/\&\&} $>$ \cd{|/||} $>$ \cd{\~{}} $>$ \cd{-> ->>} $>$ \cd{<- <<-}\\
\W \cd{!x == y} means \cd{(!x) == y}, not \cd{!(x==y)}.\\
\cd{-2\^{}2}\ra \cd{-4} (power before negation!). \cd{(-2)\^{}2}\ra \cd{4}.\\
\cd{1:5 + 1}\ra \cd{c(2,3,4,5,6)} (\cd{:} binds tighter than \cd{+}).\\
\cd{1:(5+1)}\ra \cd{c(1,2,3,4,5,6)}.

% ─────────────────────────────────────────────────
\sect{cblue}{SUBSETTING}
% ─────────────────────────────────────────────────

\sub{Atomic vectors --- 4 methods}
\textbf{1. Positive int:} \cd{x[c(3,1)]}\ra 3rd, 1st. Dupes OK: \cd{x[c(1,1)]}.\\
\W Reals \textbf{truncated}: \cd{x[2.9]}\ra same as \cd{x[2]}.\\
\textbf{2. Negative int:} \cd{x[-c(1,3)]}\ra all except 1st, 3rd.\\
\W \textbf{Cannot mix +/-}: \cd{x[c(-1,2)]}\ra \textbf{ERROR}.\\
\textbf{3. Logical:} \cd{x[c(T,F,T,F)]}\ra 1st, 3rd. Recycled if shorter.\\
\W NA in index\ra NA in output: \cd{x[c(T,NA)]}\ra \cd{val, NA, val, NA}.\\
\textbf{4. Character:} (named vec) \cd{y["a"]}. No partial matching with \cd{[}.\\
Names must match \textbf{exactly}: \cd{z["a"]} on \cd{c(abc=1)}\ra \cd{NA}.\\
Lookup tables: \cd{lookup[x]} to translate abbreviations.

\sub{Special cases}
\cd{x[]}\ra original. \cd{x[0]}\ra zero-length vec.\\
OOB: \cd{x[5]} on length-3\ra \cd{NA}. \cd{x[[5]]}\ra \textbf{ERROR}.

\sub{Lists: \texttt{[} vs \texttt{[[} vs \$}
\begin{tabular}{@{}l|p{5.5em}|p{5.8em}@{}}
\rowcolor{cbg} & \cd{x[1]} & \cd{x[[1]]} / \cd{x\$a}\\
\textbf{Returns} & \textbf{List} (train car) & \textbf{Contents} (inside)\\
\rowcolor{cbg!40}\cd{typeof} & Always \cd{"list"} & Type of element\\
\textbf{Multiple} & Yes \cd{x[1:3]} & \textbf{No} (single only)\\
\rowcolor{cbg!40}\textbf{Names} & Preserved & Dropped\\
\end{tabular}

\vspace{1pt}
\cd{x[[c(1,2)]]}\ra recursive: \cd{x[[1]][[2]]}.\\
OOB: \cd{l[4]}\ra list w/ \cd{NULL}. \cd{l[[4]]}\ra \textbf{ERROR}.\\
\cd{l[NULL]}\ra empty list. \cd{l[[NULL]]}\ra \textbf{ERROR}.\\
\cd{\$} does \textbf{partial matching}: \cd{l\$na} may match \cd{l\$name} silently!\\
\cd{[[} does NOT partial match: \cd{l[["na"]]}\ra \cd{NULL}.\\
On atomic: \cd{x[1]}\ra keeps names. \cd{x[[1]]}\ra drops names.

\sub{Matrices}
\cd{a[1:2,]}\ra rows 1--2. \cd{a[,c("B","A")]}\ra cols B, A.\\
Single row/col\ra \textbf{simplifies to vector}. Prevent: \cd{drop=FALSE}.\\
Stored in \textbf{column-major}: \cd{a[8]} = 8th element column-wise.\\
Matrix index: each row = coordinates. \cd{vals[select]}\ra vector.

\sub{Data frames}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\textbf{Syntax} & \textbf{Returns} & \textbf{Style}\\
\cd{df["x"]} & data.frame & list (preserves)\\
\rowcolor{cbg!40}\cd{df[,"x"]} & vector & matrix (simplifies)\\
\cd{df\$x} / \cd{df[["x"]]} & vector & list (simplifies)\\
\rowcolor{cbg!40}\cd{df[1,]} & data.frame row & matrix-style\\
\cd{df[c(1,3)]} & cols 1,3 (df) & list (no comma!)\\
\end{tabular}

\vspace{1pt}
\W \cd{mtcars[mtcars\$cyl<=5]}\ra \textbf{ERROR} (forgot comma --- selects cols!)\\
\textbf{Fix:} \cd{mtcars[mtcars\$cyl<=5, ]}\\
\W \cd{mtcars\$cyl==4|6}\ra always TRUE (\cd{6}\ra\cd{TRUE}).\\
\textbf{Fix:} \cd{cyl==4 | cyl==6} or \cd{cyl \%in\% c(4,6)}.\\
\W \cd{mtcars[1:13]}\ra ERROR (13 cols, only 11!). Fix: \cd{mtcars[1:13,]}.

\sub{Simplifying vs Preserving}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\textbf{Type} & \textbf{Preserving} & \textbf{Simplifying}\\
Atomic & \cd{x[1]} (names) & \cd{x[[1]]} (no names)\\
\rowcolor{cbg!40}List & \cd{x[1]} (list) & \cd{x[[1]]} (contents)\\
Factor & \cd{x[1]} (all lvls) & \cd{x[1,drop=T]}\\
\rowcolor{cbg!40}Matrix & \cd{a[1,,drop=F]} & \cd{a[1,]} (vector)\\
Data frame & \cd{df["x"]} (df) & \cd{df[,"x"]} (vector)\\
\end{tabular}

% ═══════════════════════════════════════════════════
%  PAGE 2 — PROGRAMMING
% ═══════════════════════════════════════════════════

% ─────────────────────────────────────────────────
\sect{cgreen}{CONTROL FLOW}
% ─────────────────────────────────────────────────

\sub{if() --- requires single non-NA logical}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Condition} & \textbf{Result}\\
Length $> 1$ & ERROR: ``condition has length $> 1$''\\
\rowcolor{cbg!40}\cd{NA} & ERROR: ``missing value where T/F needed''\\
Length 0 & ERROR: ``argument is of length zero''\\
\end{tabular}

\vspace{1pt}
\cd{else} \textbf{must} be on same line as closing \cd{\}}.\\
Once TRUE, remaining \cd{else if} blocks \textbf{skipped}.\\
\cd{ifelse(cond,yes,no)}\ra \textbf{vectorized}. Evaluates ALL branches.\\
\cd{case\_when(c1\~{}v1, c2\~{}v2, TRUE\~{}default)}: vectorized multi-cond.\\
Use \cd{any()}/\cd{all()} to reduce vector to single logical for \cd{if()}.

\sub{Loops}
\cd{for(x in vec)\{...\}}: iterates any vector/list.\\
\cd{while(cond)\{...\}}: after exit, counter one past end.\\
\cd{repeat\{...; if(...) break\}}: infinite until \cd{break}.\\
\cd{break}\ra exit loop. \cd{next}\ra skip to next iteration.\\
\cd{for(i in 1:10)\{if(i\%\%2==0) break; cat(i)\}}\ra prints \cd{1} only.\\
\cd{for(i in 1:10)\{if(i\%\%2==0) next; cat(i)\}}\ra \cd{1 3 5 7 9}.

\sub{Pre-allocate!}
\cd{res <- rep(NA, n)} then fill. NOT \cd{c(res,val)} (100x slower).\\
\W \cd{1:length(l)} when empty\ra \cd{c(1,0)} (loops twice!).\\
Fix: \cd{seq\_along(l)} or \cd{seq\_len(n)}\ra \cd{integer(0)} when empty.


% ─────────────────────────────────────────────────
\sect{cgreen}{BASE R FUNCTIONS}
% ─────────────────────────────────────────────────

\sub{Searching \& matching}
\cd{which(x > 5)}\ra \textbf{indices} where TRUE. Ignores NA.\\
\cd{which.min(x)}, \cd{which.max(x)}\ra index of min/max.\\
\cd{match(x, table)}\ra 1st index of x in table (\cd{NA} if none).\\
\cd{match(c(3,5,1), c(1,2,3))}\ra \cd{c(3,NA,1)}.

\sub{Sequence \& repetition}
\cd{seq(from, to, by)} or \cd{seq(from, to, length.out=n)}.\\
\cd{seq\_along(x)}\ra safe \cd{1:length(x)}. \cd{seq\_len(n)}\ra safe \cd{1:n}.\\
\cd{rep(x, times=3)}\ra repeat whole 3x. \cd{rep(x, each=3)}\ra each 3x.\\
\cd{rep(c(1,2), times=c(3,2))}\ra \cd{c(1,1,1,2,2)}.

\sub{Sorting \& ordering}
\cd{sort(x)}\ra sorted values. \cd{rev(x)}\ra reversed.\\
\cd{order(x)}\ra indices that would sort. \cd{x[order(x)]}\ra \cd{sort(x)}.\\
\cd{df[order(df\$age),]}\ra sort df by age. \cd{order(x, decreasing=T)}.

\sub{Counting \& uniqueness}
\cd{table(x)}\ra freq table. \cd{table(x,y)}\ra cross-tab.\\
\cd{unique(x)}\ra unique values. \cd{duplicated(x)}\ra logical.\\
\cd{nrow()}, \cd{ncol()}, \cd{dim()}, \cd{str()}, \cd{summary()}, \cd{head()}, \cd{tail()}.



% ═══════════════════════════════════════════════════
%  PAGE 3 — OOP \& TIDYVERSE
% ═══════════════════════════════════════════════════

% ─────────────────────────────────────────────────
\sect{cred}{S3 OOP}
% ─────────────────────────────────────────────────

\sub{Setup --- one example for everything}
\cd{f <- function(x) UseMethod("f")}\quad\textit{generic (must have UseMethod)}\\
\cd{f.j <- function(x) x+2}\quad\textit{method for class ``j''}\\
\cd{f.k <- function(x) x+10}\quad\textit{method for class ``k''}\\
\cd{f.default <- function(x) x+100}\quad\textit{fallback if no match}

\sub{How dispatch works: f(obj) traces}
\cd{f(obj)}\ra R reads \cd{class(obj)}, tries \cd{f.class1}, \cd{f.class2}, ..., \cd{f.default}, else ERROR.

\vspace{2pt}
\cd{k <- 1}\quad\textit{no class attr, k is a plain double}\\
\cd{f(k)}\ra try \cd{f.double}? \textbf{No}\ra \cd{f.numeric}? \textbf{No}\ra \cd{f.default}\ra $1+100=$ \cd{101}

\vspace{2pt}
\cd{class(k) <- "j"}\quad\textit{now k has class ``j''}\\
\cd{f(k)}\ra try \cd{f.j}? \textbf{Yes}\ra $1+2=$ \cd{3}

\vspace{2pt}
\cd{f(structure(10, class=c("k","l")))}\quad\textit{class vector: try left to right}\\
\ra try \cd{f.k}? \textbf{Yes} (first match)\ra $10+10=$ \cd{20}

\vspace{2pt}
\cd{f(structure(10, class=c("m","n")))}\quad\textit{no f.m or f.n}\\
\ra \cd{f.m}? No\ra \cd{f.n}? No\ra \cd{f.default}\ra $10+100=$ \cd{110}

\sub{Implicit classes (no class attr set)}
\cd{7} is double\ra dispatch tries: \cd{f.double}\ra \cd{f.numeric}\ra \cd{f.default}\\
\cd{7L} is integer\ra dispatch tries: \cd{f.integer}\ra \cd{f.numeric}\ra \cd{f.default}\\
\cd{f.integer <- function(x) 100*x}\\
\cd{f(7)}\ra \cd{107} (double path). \cd{f(7L)}\ra \cd{700} (integer path).

\sub{Traps (using same example)}
\W \cd{f.j(7)}\ra \cd{9}: direct call \textbf{skips dispatch}, just runs $7+2$!\\
\W \cd{f <- function(x) UseMethod("g")}\ra dispatches \cd{g.class} not \cd{f.class}!\\
\W Generic without \cd{UseMethod()}\ra methods \textbf{never} called.\\
\W No matching method + no \cd{.default}\ra \textbf{ERROR}.

\sub{Creating S3 objects}
\cd{obj <- structure(list(name="apple"), class="fruit")}\\
Or: \cd{obj <- list(...); class(obj) <- "fruit"}\\
Inheritance: \cd{class(obj) <- c("apple","fruit")} (tries left to right).\\
\W Use \cd{inherits(obj,"fruit")}, NOT \cd{class(obj)=="fruit"}.

% ─────────────────────────────────────────────────
\sect{cred}{R6 OOP}
% ─────────────────────────────────────────────────

\textbf{Encapsulated OOP}: methods belong to \textbf{objects}. \cd{library(R6)}.

\sub{Example: Clock class}
\cd{Clock <- R6Class("Clock", public = list(}\\
\cd{\ \ hour=0, minute=0, second=0,}\\
\cd{\ \ add\_hour = function(x) \{}\\
\cd{\ \ \ \ self\$hour <- (self\$hour + 1)\%\%24}\\
\cd{\ \ \ \ invisible(self) \},}\\
\cd{\ \ add\_minute = function(x) \{}\\
\cd{\ \ \ \ self\$minute <- (self\$minute + 1)\%\%60}\\
\cd{\ \ \ \ invisible(self) \},}\\
\cd{\ \ add\_second = function(x) \{}\\
\cd{\ \ \ \ self\$second <- (self\$second + 1)\%\%60}\\
\cd{\ \ \ \ invisible(self) \},}\\
\cd{\ \ print = function(...) \{}\\
\cd{\ \ \ \ cat("Hour:", self\$hour, "\textbackslash n")}\\
\cd{\ \ \ \ cat("Minute:", self\$minute, "\textbackslash n")}\\
\cd{\ \ \ \ cat("Second:", self\$second, "\textbackslash n")}\\
\cd{\ \ \ \ invisible(self) \}))}

\sub{Usage: new(), chaining, \$set()}
\cd{clock1 <- Clock\$new()}\\
\cd{clock1\$add\_hour()\$add\_hour()\$add\_second()}\\
\cd{clock1}\quad\ra\quad \cd{Hour: 2 / Minute: 0 / Second: 1}\\[1pt]
\cd{Clock\$set("public", "clock\_type", "analog")}\\
\cd{clock1}\quad\ra\quad still \cd{Hour: 2 / Minute: 0 / Second: 1}\\
\W \cd{\$set()} only affects \textbf{new} objects, not existing ones!

\sub{Key concepts}
\cd{self\$}\ra access own fields/methods. \cd{invisible(self)}\ra chaining.\\
\cd{\$initialize()}\ra overrides \cd{\$new()}. \cd{\$print()}\ra custom print.\\
\W \textbf{Without \cd{invisible(self)}, chaining FAILS!}\\
\cd{clock1\$add\_hour()\$add\_hour()}\ra ERROR: ``\cd{\$} operator is\\
invalid for atomic vectors'' (method returns \cd{NULL}, not \cd{self}).

\sub{Inheritance \& Reference semantics}
\cd{R6Class("Child", inherit=Parent)}. \cd{super\$method()} for parent.\\
\cd{class(x)}\ra \cd{c("Child","Parent","R6")}.\\
\cd{y <- x}\ra \textbf{SAME object}! \cd{y\$set(10)} changes x too!\\
\cd{y <- x\$clone()}\ra independent. \cd{\$clone(deep=TRUE)}\ra deep copy.\\
Functions can modify R6 args without assignment: \cd{f(x)} changes x!

% ─────────────────────────────────────────────────
\sect{corange}{DPLYR}
% ─────────────────────────────────────────────────

\cd{df <- data.frame(name=c("A","B","C","A"),}\\
\cd{\ \ age=c(20,25,30,22), score=c(80,90,70,85))}

\begin{tabular}{@{}l|l|l|l@{}}
\rowcolor{cbg} & \cd{name} & \cd{age} & \cd{score}\\
1 & \cd{A} & \cd{20} & \cd{80}\\
\rowcolor{cbg!40}2 & \cd{B} & \cd{25} & \cd{90}\\
3 & \cd{C} & \cd{30} & \cd{70}\\
\rowcolor{cbg!40}4 & \cd{A} & \cd{22} & \cd{85}\\
\end{tabular}

\sub{select() --- choose columns}
\cd{df |> select(name, age)}\ra keeps only name, age cols\\
\cd{df |> select(-score)}\ra same (drop score)\\
\cd{df |> select(n=name)}\ra renames name to n

\sub{filter() --- keep rows}
\cd{df |> filter(age > 22)}\ra rows 2,3 (B/25/90, C/30/70)\\
\cd{df |> filter(name=="A", age>20)}\ra row 4 only (comma=AND)\\
\W \cd{filter(df, name = "A")}\ra \textbf{error}! Use \cd{==} not \cd{=}.

\sub{mutate() --- add/transform columns}
\cd{df |> mutate(pass = score >= 80)}\ra adds col:

\begin{tabular}{@{}l|l|l|l@{}}
\rowcolor{cbg}\cd{name} & \cd{age} & \cd{score} & \cd{pass}\\
\cd{A} & \cd{20} & \cd{80} & \cd{TRUE}\\
\rowcolor{cbg!40}\cd{B} & \cd{25} & \cd{90} & \cd{TRUE}\\
\cd{C} & \cd{30} & \cd{70} & \cd{FALSE}\\
\rowcolor{cbg!40}\cd{A} & \cd{22} & \cd{85} & \cd{TRUE}\\
\end{tabular}

\vspace{1pt}
Keeps all cols. \cd{transmute()}\ra only new cols.

\sub{arrange() --- sort rows}
\cd{df |> arrange(age)}\ra 20, 22, 25, 30\\
\cd{df |> arrange(desc(score))}\ra 90, 85, 80, 70

\sub{group\_by + summarize}
\cd{df |> group\_by(name) |>}\\
\cd{\ \ summarize(avg=mean(score), n=n())}

\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\cd{name} & \cd{avg} & \cd{n}\\
\cd{A} & \cd{82.5} & \cd{2}\\
\rowcolor{cbg!40}\cd{B} & \cd{90} & \cd{1}\\
\cd{C} & \cd{70} & \cd{1}\\
\end{tabular}

\vspace{1pt}
\cd{n()}\ra count rows. \cd{n\_distinct(col)}\ra unique count.\\
\cd{group\_by + mutate}\ra adds col within group.\\
\cd{ungroup()} to remove grouping after.

\sub{Other verbs}
\cd{df |> count(name)}\ra \cd{A:2, B:1, C:1}\\
\cd{df |> distinct(name)}\ra \cd{A, B, C}\\
\cd{df |> slice(1:2)}\ra first 2 rows\\
\cd{df |> pull(age)}\ra \cd{c(20,25,30,22)} (vector!)

\sub{Joins}
\cd{x = data.frame(id=c(1,2,3), n=c("A","B","C"))}\\
\cd{y = data.frame(id=c(2,3,4), s=c(90,80,70))}

\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Join} & \textbf{Result (id, n, s)}\\
\cd{left\_join(x,y)} & \cd{1/A/NA, 2/B/90, 3/C/80}\\
\rowcolor{cbg!40}\cd{right\_join(x,y)} & \cd{2/B/90, 3/C/80, 4/NA/70}\\
\cd{inner\_join(x,y)} & \cd{2/B/90, 3/C/80}\\
\rowcolor{cbg!40}\cd{full\_join(x,y)} & \cd{1/A/NA, 2/B/90, 3/C/80, 4/NA/70}\\
\cd{semi\_join(x,y)} & \cd{2/B, 3/C} (no y cols added)\\
\rowcolor{cbg!40}\cd{anti\_join(x,y)} & \cd{1/A} (x rows w/ \textbf{no} match)\\
\end{tabular}

\vspace{1pt}
\cd{left\_join(x, y, by=join\_by(a == b))}. Same name: \cd{join\_by(x)}.\\
No match\ra \cd{NA}. Non-unique\ra \textbf{Cartesian product}.\\
Set ops: \cd{intersect()}, \cd{union()}, \cd{setdiff()} on rows.

% ─────────────────────────────────────────────────
\sect{corange}{TIDYR: RESHAPING}
% ─────────────────────────────────────────────────

\noindent\includegraphics[width=\columnwidth]{pivot.png}

% ─────────────────────────────────────────────────
\sect{cpurple}{STRINGS \& REGEX}
% ─────────────────────────────────────────────────

\sub{stringr functions}
\cd{s <- c("apple 3", "banana 12", "cherry")}

\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Function} & \textbf{Example \& Result}\\
\cd{str\_detect(s,p)} & \cd{str\_detect(s,"\textbackslash\textbackslash d")}\ra \cd{T, T, F}\\
\rowcolor{cbg!40}\cd{str\_extract(s,p)} & \cd{str\_extract(s,"\textbackslash\textbackslash d+")}\ra \cd{"3","12",NA}\\
\cd{str\_match(s,p)} & \cd{str\_match(s,"(\textbackslash\textbackslash w+) (\textbackslash\textbackslash d+)")}\ra matrix\\
 & col1=full, col2=\cd{"apple","banana",NA}\\
\rowcolor{cbg!40}\cd{str\_replace(s,p,r)} & \cd{str\_replace(s,"a","X")}\ra \cd{"Xpple 3",...}\\
\cd{str\_replace\_all} & \cd{str\_replace\_all(s,"a","X")}\ra \cd{"Xpple 3","bXnXnX 12",...}\\
\rowcolor{cbg!40}\cd{str\_split(s,p)} & \cd{str\_split("a.b.c","\textbackslash\textbackslash.")}\ra \cd{list(c("a","b","c"))}\\
\cd{str\_count(s,p)} & \cd{str\_count(s,"a")}\ra \cd{1, 3, 0}\\
\end{tabular}

\vspace{1pt}
\cd{\_all} suffix: ALL matches. \cd{str\_extract\_all}\ra \textbf{list} (not vector!).

\sub{Regex metacharacters (escape: \texttt{\textbackslash\textbackslash})}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\textbf{Symbol} & \textbf{Meaning} & \textbf{Example}\\
\cd{.} & any single char & \cd{"h.t"}\ra \cd{"hat","hot"}\\
\rowcolor{cbg!40}\cd{\^{}} & start of string & \cd{"\^{}Hi"}\ra \cd{"Hi there"}\\
\cd{\$} & end of string & \cd{"end\$"}\ra \cd{"the end"}\\
\rowcolor{cbg!40}\cd{\textbackslash\textbackslash d} & digit (0--9) & \cd{"\textbackslash\textbackslash d+"}\ra \cd{"123"}\\
\cd{\textbackslash\textbackslash w} & word (a--z,0--9,\_) & \cd{"\textbackslash\textbackslash w+"}\ra \cd{"hi\_2"}\\
\rowcolor{cbg!40}\cd{\textbackslash\textbackslash s} & whitespace & \cd{"\textbackslash\textbackslash s+"}\ra \cd{" "}\\
\cd{\textbackslash\textbackslash b} & word boundary & \cd{"\textbackslash\textbackslash bcat\textbackslash\textbackslash b"} skips \cd{"catch"}\\
\rowcolor{cbg!40}\cd{[\^{}...]} & negation in \cd{[]} & \cd{[\^{}aeiou]} = not vowel\\
\end{tabular}

\vspace{1pt}
\sub{Caret \cd{\^{}} --- 3 meanings by position}
\cd{"\^{}Hi"}\ra matches \cd{"Hi there"}, not \cd{"say Hi"} (start anchor)\\
\cd{"[\^{}aeiou]"}\ra matches \cd{"b","c","d",...} (negation inside \cd{[]})\\
\cd{"[abc\^{}]"}\ra matches \cd{a,b,c,\^{}} (literal when not first in \cd{[]})\\
Inside \cd{[]}: most metachar literal. Exceptions: \cd{] - \^{} \textbackslash}.

\sub{Quantifiers \& Greedy/Lazy}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\textbf{Quant.} & \textbf{Meaning} & \textbf{Example}\\
\cd{*} & 0 or more & \cd{"ab*"}\ra \cd{"a","ab","abbb"}\\
\rowcolor{cbg!40}\cd{+} & 1 or more & \cd{"ab+"}\ra \cd{"ab","abbb"}\\
\cd{?} & 0 or 1 (optional) & \cd{"ab?"}\ra \cd{"a"} or \cd{"ab"}\\
\rowcolor{cbg!40}\cd{\{n\}} & exactly n & \cd{"b\{2\}"}\ra \cd{"bb"}\\
\cd{\{n,\}} & n or more & \cd{"b\{2,\}"}\ra \cd{"bb","bbb"}\\
\rowcolor{cbg!40}\cd{\{n,m\}} & between n and m & \cd{"b\{1,2\}"}\ra \cd{"b","bb"}\\
\end{tabular}

\vspace{1pt}
\textbf{Greedy} (default): longest match. Add \cd{?} after for \textbf{lazy} (shortest).\\
\cd{str\_extract("Peter Piper","P.*r")}\ra \cd{"Peter Piper"} (greedy).\\
\cd{str\_extract("Peter Piper","P.*?r")}\ra \cd{"Peter"} (lazy).

\sub{Groups \& Backreferences}
\cd{(abc)}\ra capture. \cd{(?:abc)}\ra non-capture. \cd{|}\ra alternation.\\
\W Order matters: \cd{(Mr|Mrs)} on ``Mrs.''\ra \cd{"Mr"} (first wins!).\\
\cd{\textbackslash\textbackslash 1}/\cd{\textbackslash\textbackslash 2} in replacement reference groups.\\
\cd{str\_match}\ra matrix: col1=full, col2+=groups.

\sub{Lookarounds (zero-width, not consumed)}
\cd{(?=...)}\ra pos ahead. \cd{(?!...)}\ra neg ahead.\\
\cd{(?<=...)}\ra pos behind. \cd{(?<!...)}\ra neg behind.\\
Lookbehind: \textbf{bounded length only} (no \cd{*}/\cd{+}).

% ─────────────────────────────────────────────────
\sect{cred}{WHEN DOES R OUTPUT NA / NaN / NULL / Inf?}
% ─────────────────────────────────────────────────

\sub{NA --- ``I don't know''}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Situation} & \textbf{Example}\\
Any math with NA & \cd{NA + 1}\ra\cd{NA}, \cd{NA * 0}\ra\cd{NA}\\
\rowcolor{cbg!40}Comparison with NA & \cd{NA == NA}\ra\cd{NA}, \cd{NA > 5}\ra\cd{NA}\\
Logic (undetermined) & \cd{NA \& TRUE}\ra\cd{NA}, \cd{NA | FALSE}\ra\cd{NA}\\
\rowcolor{cbg!40}OOB with \cd{[} & \cd{x[10]} on length-3\ra\cd{NA}\\
No match & \cd{match(5, c(1,2))}\ra\cd{NA}\\
\rowcolor{cbg!40}Coercion failure & \cd{as.numeric("dog")}\ra\cd{NA}\\
Bad factor level & assign value not in levels\ra\cd{NA}\\
\end{tabular}

\sub{NaN --- ``Undefined math'' (is also NA!)}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Situation} & \textbf{Example}\\
0 divided by 0 & \cd{0/0}\ra\cd{NaN}\\
\rowcolor{cbg!40}Inf minus Inf & \cd{Inf - Inf}\ra\cd{NaN}\\
Inf times 0 & \cd{Inf * 0}\ra\cd{NaN}\\
\rowcolor{cbg!40}Negative sqrt/log & \cd{sqrt(-1)}\ra\cd{NaN}, \cd{log(-1)}\ra\cd{NaN}\\
\end{tabular}

\vspace{1pt}
\cd{is.na(NaN)}\ra\cd{TRUE} (NaN is a kind of NA). \cd{is.nan(NA)}\ra\cd{FALSE}.

\sub{NULL --- ``Nothing exists''}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Situation} & \textbf{Example}\\
Nonexistent list element & \cd{list()\$x}\ra\cd{NULL}\\
\rowcolor{cbg!40}Dropped in \cd{c()} & \cd{c(1, NULL, 3)}\ra\cd{c(1, 3)}\\
NULL in math & \cd{NULL + 1}\ra\cd{numeric(0)}\\
\rowcolor{cbg!40}Length is 0 & \cd{length(NULL)}\ra\cd{0}\\
\end{tabular}

\sub{Inf --- ``Infinity''}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Situation} & \textbf{Example}\\
Divide by zero & \cd{1/0}\ra\cd{Inf}, \cd{-1/0}\ra\cd{-Inf}\\
\rowcolor{cbg!40}Log of zero & \cd{log(0)}\ra\cd{-Inf}\\
Inf in math & \cd{Inf + 1}\ra\cd{Inf}\\
\end{tabular}

\vspace{2pt}
\sub{Quick contrast}
\cd{0/0}\ra\cd{NaN}. \cd{1/0}\ra\cd{Inf}. \cd{NA+1}\ra\cd{NA}. \cd{NULL+1}\ra\cd{numeric(0)}.


\end{multicols}
\end{document}
