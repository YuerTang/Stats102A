\documentclass[10pt]{article}
\usepackage[margin=0.13in]{geometry}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{amsmath,amssymb}
\usepackage{array}
\usepackage{colortbl}
\usepackage{tabularx}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\pagestyle{empty}

% ── COLORS ──────────────────────────────────────
\definecolor{cblue}{HTML}{1E40AF}
\definecolor{cgreen}{HTML}{166534}
\definecolor{corange}{HTML}{C2410C}
\definecolor{cpurple}{HTML}{7E22CE}
\definecolor{cred}{HTML}{B91C1C}
\definecolor{cteal}{HTML}{0F766E}
\definecolor{cbg}{HTML}{EDF2FF}
\definecolor{rulecolor}{HTML}{CBD5E1}

% ── SECTION HEADER ──
\newcommand{\sect}[2]{%
  \vspace{3.5pt}%
  {\noindent\fontsize{5.5}{6.3}\selectfont\sffamily\bfseries\textcolor{#1}{\rule{1.5pt}{5.5pt}\;\,#2}\par\nobreak}%
  \vspace{-1pt}\noindent{\color{#1}\rule{\columnwidth}{0.5pt}}\vspace{1.5pt}\par\nobreak%
}

% ── SUB-HEADER ──
\newcommand{\sub}[1]{%
  \vspace{1.5pt}{\noindent\fontsize{4.2}{5.0}\selectfont\sffamily\bfseries #1}\vspace{0.5pt}\par\nobreak%
}

% ── CODE (monospace) ──
\newcommand{\cd}[1]{{\fontsize{3.8}{4.5}\selectfont\texttt{#1}}}

% ── Arrows and markers ──
\newcommand{\ra}{\,{\fontsize{3.3}{3.3}\selectfont$\boldsymbol{\rightarrow}$}\,}
\newcommand{\W}{\textcolor{cred}{\fontsize{4.1}{4.1}\selectfont$\blacktriangleright$}\,}

% ── Tight itemize ──
\setlist[itemize]{leftmargin=5pt, itemsep=0pt, parsep=0pt, topsep=0.5pt, partopsep=0pt, label={\tiny$\bullet$}}

% ── Table defaults ──
\setlength{\tabcolsep}{2pt}
\renewcommand{\arraystretch}{1.0}

\begin{document}

% ═══════════════════════════════════════════════════
%  PAGE 1
% ═══════════════════════════════════════════════════

\fontsize{4.2}{5.2}\selectfont
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.3pt}
\setlength{\columnsep}{4pt}
\setlength{\columnseprule}{0.15pt}
\def\columnseprulecolor{\color{rulecolor}}

\begin{multicols}{3}

% ─────────────────────────────────────────────────
\sect{cblue}{DATA TYPES \& STRUCTURES}
% ─────────────────────────────────────────────────

\sub{6 Atomic Types (coercion order)}
\cd{logical} $<$ \cd{integer} $<$ \cd{double} $<$ \cd{character} $<$ \cd{complex} $<$ \cd{raw}

\sub{typeof() vs class() vs mode()}
\begin{tabular}{@{}l|l|l|l@{}}
\rowcolor{cbg}\textbf{Object} & \cd{typeof} & \cd{class} & \cd{mode}\\
\cd{TRUE} & \cd{"logical"} & \cd{"logical"} & \cd{"logical"}\\
\rowcolor{cbg!40}\cd{1L} & \cd{"integer"} & \cd{"integer"} & \cd{"numeric"}\\
\cd{3.14} & \cd{"double"} & \cd{"numeric"} & \cd{"numeric"}\\
\rowcolor{cbg!40}\cd{"hi"} & \cd{"character"} & \cd{"character"} & \cd{"character"}\\
\cd{1:3} & \cd{"integer"} & \cd{"integer"} & \cd{"numeric"}\\
\rowcolor{cbg!40}\cd{c(1,2)} & \cd{"double"} & \cd{"numeric"} & \cd{"numeric"}\\
\cd{list()} & \cd{"list"} & \cd{"list"} & \cd{"list"}\\
\rowcolor{cbg!40}\cd{data.frame()} & \cd{"list"} & \cd{"data.frame"} & \cd{"list"}\\
\cd{factor("a")} & \cd{"integer"} & \cd{"factor"} & \cd{"numeric"}\\
\rowcolor{cbg!40}\cd{function(){}} & \cd{"closure"} & \cd{"function"} & \cd{"function"}\\
\cd{NULL} & \cd{"NULL"} & \cd{"NULL"} & \cd{"NULL"}\\
\rowcolor{cbg!40}\cd{NA} & \cd{"logical"} & \cd{"logical"} & \cd{"logical"}\\
\end{tabular}

\vspace{1pt}
\W \cd{is.numeric(x)}\ra \cd{TRUE} for \textbf{both} integer and double!\\
\cd{is.double(1L)}\ra \cd{FALSE}. \cd{is.numeric(1L)}\ra \cd{TRUE}.

\sub{Key Structures}
\textbf{Matrix:} atomic vector + \cd{dim} attr. Filled \textbf{column-wise}.\\
\cd{attr(M,"dim") <- c(2,5)} turns length-10 vec into $2{\times}5$ matrix.\\
\cd{attr(M,"dim") <- NULL}\ra back to plain vector.\\
\cd{class(M)}\ra \cd{c("matrix","array")} when dim set.\\
\textbf{Array:} atomic vector with \cd{dim} length $>2$.\\
\textbf{Data frame:} \cd{typeof}=\cd{"list"}, \cd{class}=\cd{"data.frame"}.\\
\cd{attributes(df)}\ra list with \cd{names}, \cd{class}, \cd{row.names}.\\
\textbf{Attributes:} \cd{attr(x,"info")<-"..."} sets metadata.\\
\cd{attributes(x)}\ra full list. \cd{attr(x,"dim")}\ra get one.

\sub{Factors}
Integer vector with \cd{levels} + \cd{class} attributes.\\
Levels sorted \textbf{alphabetically}: \cd{factor(c("M","F","F"))}\ra levels \cd{c("F","M")}.\\
\cd{as.integer(factor(c("M","F","F")))}\ra \cd{c(2,1,1)}.\\
\W Assigning value not in levels\ra becomes \cd{NA} with warning.\\
\W \textbf{Numeric factor trap:}\\
\cd{as.numeric(factor(c(0,1,10,5)))}\ra \cd{c(1,2,4,3)} (indices!)\\
\textbf{Fix:} \cd{as.numeric(as.character(x\_fac))}

\sub{identical() vs ==}
\cd{==} is vectorized, \cd{NA} propagates. \cd{identical()} returns single T/F.\\
\cd{identical(NA, NA)}\ra \cd{TRUE}. \cd{NA == NA}\ra \cd{NA}.\\
\cd{identical(1, 1L)}\ra \cd{FALSE} (type matters!). \cd{identical(1L, 1L)}\ra \cd{TRUE}.\\
\cd{all.equal(1, 1L)}\ra \cd{TRUE} (near-equality, ignores type).\\
\cd{all.equal(0.1+0.2, 0.3)}\ra \cd{TRUE}. \cd{0.1+0.2 == 0.3}\ra \cd{FALSE} (float!).

\sub{Type checking \& conversion}
\cd{is.numeric()}\ra TRUE for int AND double. \cd{is.atomic()}\ra TRUE for vec.\\
\cd{as.integer(3.9)}\ra \cd{3} (truncates). \cd{as.double(TRUE)}\ra \cd{1}.\\
\cd{as.character(123)}\ra \cd{"123"}. \cd{as.numeric("3.14")}\ra \cd{3.14}.\\
\cd{is.vector(list())}\ra \cd{TRUE}. \cd{is.atomic(list())}\ra \cd{FALSE}.\\
\cd{unlist(list(1,c(2,3)))}\ra \cd{c(1,2,3)}.

% ─────────────────────────────────────────────────
\sect{cblue}{COERCION RULES}
% ─────────────────────────────────────────────────

\sub{Combining different types with c()}
\cd{c(TRUE,1L,2.5)}\ra double \cd{c(1.0,1.0,2.5)}\\
\cd{c(TRUE,1,"a")}\ra character \cd{c("TRUE","1","a")}\\
\cd{c(FALSE,1L)}\ra integer \cd{c(0L,1L)}

\sub{Implicit coercion}
\cd{TRUE}\ra\cd{1}, \cd{FALSE}\ra\cd{0} in math.\\
\cd{sum(c(T,F,T))}\ra\cd{2}. \cd{mean(c(T,F,T))}\ra\cd{0.667}.

\sub{as.logical() rules}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Input} & \textbf{Result}\\
\cd{as.logical(0)} & \cd{FALSE}\\
\rowcolor{cbg!40}\cd{as.logical(1)} & \cd{TRUE}\\
\cd{as.logical(-1)} & \cd{TRUE} (any nonzero$\ne$NaN)\\
\rowcolor{cbg!40}\cd{as.logical(NaN)} & \cd{NA}\\
\cd{as.logical("TRUE"/"true"/"T")} & \cd{TRUE}\\
\rowcolor{cbg!40}\cd{as.logical("False"/"false"/"F")} & \cd{FALSE}\\
\cd{as.logical("t"/"1"/"0")} & \cd{NA}\\
\end{tabular}

\vspace{1pt}
Accepted: \cd{"TRUE","True","true","T","FALSE","False","false","F"} only.\\
\W \cd{as.logical(c("0",1))}\ra all coerced to \textbf{char} first\ra all \cd{NA}.\\
\cd{as.numeric("dog")}\ra \cd{NA} with warning.\\
\cd{as.integer(TRUE)}\ra \cd{1L}. \cd{as.integer(FALSE)}\ra \cd{0L}.\\
\cd{as.character(TRUE)}\ra \cd{"TRUE"}. \cd{as.character(1.5)}\ra \cd{"1.5"}.

\sub{Coercion in matrix/data.frame}
Matrix: all elements same type (coerced). \cd{matrix(c(1,"a"))}\ra all char.\\
Data frame: each column can be different type (list of columns).\\
\cd{cbind()} on mixed types\ra coerces to most general (matrix).\\
\cd{data.frame(x=1:3, y=c("a","b","c"))}\ra preserves types.

% ─────────────────────────────────────────────────
\sect{cblue}{SPECIAL VALUES: NA, NULL, NaN, Inf}
% ─────────────────────────────────────────────────

\begin{tabular}{@{}l|p{4.2em}|p{4.2em}|p{3.5em}|p{3.2em}@{}}
\rowcolor{cbg} & \textbf{NA} & \textbf{NULL} & \textbf{NaN} & \textbf{Inf}\\
\textbf{Meaning} & Missing & Empty & 0/0 & $\infty$\\
\rowcolor{cbg!40}\cd{typeof} & \cd{"logical"} & \cd{"NULL"} & \cd{"double"} & \cd{"double"}\\
\textbf{In c()} & Kept & Dropped & Kept & Kept\\
\rowcolor{cbg!40}\cd{length} & \cd{1} & \cd{0} & \cd{1} & \cd{1}\\
\cd{is.na()} & \cd{TRUE} & \cd{lgcl(0)} & \cd{TRUE} & \cd{FALSE}\\
\rowcolor{cbg!40}\cd{is.null()} & \cd{FALSE} & \cd{TRUE} & \cd{FALSE} & \cd{FALSE}\\
\cd{is.finite()} & \cd{FALSE} & --- & \cd{FALSE} & \cd{FALSE}\\
\end{tabular}

\sub{NA --- Missing / Unknown}
\cd{NA == NA}\ra \cd{NA} (must use \cd{is.na()}).\\
NA in math: \cd{NA + 1}\ra \cd{NA}. \cd{NA * 0}\ra \cd{NA} (not 0!).\\
\cd{NA \& FALSE}\ra \cd{FALSE}. \cd{NA | TRUE}\ra \cd{TRUE}. (determined!)\\
Typed: \cd{NA\_integer\_}, \cd{NA\_real\_}, \cd{NA\_character\_}, \cd{NA\_complex\_}.\\
NA in vector does NOT change vector's type.

\sub{NULL --- Empty / Nonexistent}
\cd{c(4,5,NULL,3)}\ra \cd{c(4,5,3)} (NULL silently dropped!).\\
\cd{length(NULL)}\ra \cd{0}. \cd{NULL + 1}\ra \cd{numeric(0)}.\\
\cd{NULL == NULL}\ra \cd{logical(0)} (not TRUE!). \cd{is.logical(NULL)}\ra \cd{FALSE}.\\
Remove list elements: \cd{l\$x <- NULL}. Default arg: \cd{f(x=NULL)}.

\sub{NaN and Inf}
\cd{0/0}\ra \cd{NaN}. \cd{1/0}\ra \cd{Inf}. \cd{-1/0}\ra \cd{-Inf}. \cd{log(0)}\ra \cd{-Inf}.\\
\cd{Inf - Inf}\ra \cd{NaN}. \cd{Inf + Inf}\ra \cd{Inf}. \cd{Inf * 0}\ra \cd{NaN}.\\
\cd{is.nan(NaN)}\ra \cd{TRUE}. \cd{is.na(NaN)}\ra \cd{TRUE} (NaN is also NA!).\\
\cd{is.infinite(Inf)}\ra \cd{TRUE}. \cd{max(c(1,Inf))}\ra \cd{Inf}.\\
\cd{NaN > 1}\ra \cd{NA}. \cd{Inf > 1e308}\ra \cd{TRUE}.

% ─────────────────────────────────────────────────
\sect{cblue}{VECTOR ARITHMETIC \& OPERATIONS}
% ─────────────────────────────────────────────────

\sub{Element-wise operators (all recycle)}
\cd{+\; -\; *\; /\; \^{}}\quad \cd{\%\%} (modulo)\quad \cd{\%/\%} (integer div)\\
\cd{5 \%\% 3}\ra \cd{2}. \cd{5 \%/\% 3}\ra \cd{1}. \cd{(-7) \%\% 3}\ra \cd{2} (always $\ge 0$).\\
\cd{c(10,20,30) * c(1,2,3)}\ra \cd{c(10,40,90)}.

\sub{Math functions (vectorized)}
\cd{abs()}, \cd{sqrt()}, \cd{ceiling()}, \cd{floor()}, \cd{round(x,n)}, \cd{trunc()},\\
\cd{log()}, \cd{log2()}, \cd{log10()}, \cd{exp()}, \cd{sign()}.\\
\W \cd{round(2.5)}\ra \cd{2} (banker's rounding! rounds to \textbf{even}).\\
\cd{round(3.5)}\ra \cd{4}. \cd{round(0.5)}\ra \cd{0}. \cd{round(1.5)}\ra \cd{2}.

\sub{Aggregation functions}
\cd{sum()}, \cd{prod()}, \cd{min()}, \cd{max()}, \cd{range()}, \cd{mean()}, \cd{median()},\\
\cd{var()}, \cd{sd()}, \cd{length()}, \cd{nchar()}.\\
\W All return \cd{NA} if input has NA! Fix: \cd{na.rm=TRUE}.\\
Cumulative: \cd{cumsum()}, \cd{cumprod()}, \cd{cummax()}, \cd{cummin()}.

\sub{Set operations on vectors}
\cd{union(x,y)}, \cd{intersect(x,y)}, \cd{setdiff(x,y)}, \cd{setequal(x,y)}.\\
\cd{\%in\%}: logical, vectorized on LEFT only.\\
\cd{c(1,2,3) \%in\% c(2,4)}\ra \cd{c(F,T,F)}.

% ─────────────────────────────────────────────────
\sect{cblue}{VECTOR RECYCLING}
% ─────────────────────────────────────────────────

Shorter vector \textbf{repeated} to match longer.\\
\W Warning only if longer length NOT multiple of shorter.\\
\cd{c(1,2,3)+c(100,200,300,400,500,600)}\ra \cd{c(101,202,303,401,502,603)} (no warn)\\
\cd{c(1,2,3)+c(100,200,300,400,500)}\ra \cd{c(101,202,303,401,502)} (\textbf{warning})\\
Scalar recycling: \cd{x * 2} recycles 2. No warning.\\
Matrix recycling: \textbf{column-wise} (down col 1, then col 2...).\\
Row-wise trick: \cd{t(t(M) + x)}.\\
Logical recycling: \cd{c(T,F)} recycles for every-other selection.\\
\cd{cbind}/\cd{rbind} recycle shorter to match longer.

% ─────────────────────────────────────────────────
\sect{cblue}{ASSIGNMENT OPERATORS}
% ─────────────────────────────────────────────────

\cd{<-}\ra standard (preferred). \cd{=}\ra only inside current scope.\\
\cd{->}\ra right assignment (rare). \cd{<<-}\ra super assignment (parent env).\\
\W \cd{f(x = 3)} passes arg. \cd{f(x <- 3)} assigns AND passes!\\
\cd{mean(x = 1:5)}\ra x NOT in global. \cd{mean(x <- 1:5)}\ra x IS in global.

% ─────────────────────────────────────────────────
\sect{cgreen}{SUBSETTING ATOMIC VECTORS}
% ─────────────────────────────────────────────────

\sub{4 methods}
\textbf{1. Positive int:} \cd{x[c(3,1)]}\ra 3rd, 1st. Dupes OK: \cd{x[c(1,1)]}.\\
\W Reals \textbf{truncated}: \cd{x[2.9]}\ra same as \cd{x[2]}.\\
\textbf{2. Negative int:} \cd{x[-c(1,3)]}\ra all except 1st, 3rd.\\
\W \textbf{Cannot mix +/-}: \cd{x[c(-1,2)]}\ra \textbf{ERROR}.\\
\textbf{3. Logical:} \cd{x[c(T,F,T,F)]}\ra 1st, 3rd. Recycled if shorter.\\
\W NA in index\ra NA in output: \cd{x[c(T,NA)]}\ra \cd{val, NA, val, NA}.\\
\textbf{4. Character:} (named vec) \cd{y["a"]}. No partial matching with \cd{[}.\\
Names must match \textbf{exactly}: \cd{z["a"]} on \cd{c(abc=1)}\ra \cd{NA}.\\
Lookup tables: \cd{lookup[x]} to translate abbreviations.

\sub{Special cases}
\cd{x[]}\ra original. \cd{x[0]}\ra zero-length vec.\\
OOB: \cd{x[5]} on length-3\ra \cd{NA}. \cd{x[[5]]}\ra \textbf{ERROR}.

% ─────────────────────────────────────────────────
\sect{cgreen}{SUBSETTING LISTS: \texttt{[} vs \texttt{[[} vs \$}
% ─────────────────────────────────────────────────

\begin{tabular}{@{}l|p{5.5em}|p{5.8em}@{}}
\rowcolor{cbg} & \cd{x[1]} & \cd{x[[1]]} / \cd{x\$a}\\
\textbf{Returns} & \textbf{List} (train car) & \textbf{Contents} (inside)\\
\rowcolor{cbg!40}\cd{typeof} & Always \cd{"list"} & Type of element\\
\textbf{Multiple} & Yes \cd{x[1:3]} & \textbf{No} (single only)\\
\rowcolor{cbg!40}\textbf{Names} & Preserved & Dropped\\
\end{tabular}

\vspace{1pt}
\cd{x[[c(1,2)]]}\ra recursive: \cd{x[[1]][[2]]}.\\
OOB: \cd{l[4]}\ra list w/ \cd{NULL}. \cd{l[[4]]}\ra \textbf{ERROR}.\\
\cd{l[NULL]}\ra empty list. \cd{l[[NULL]]}\ra \textbf{ERROR}.\\
\cd{\$} does \textbf{partial matching}: \cd{l\$na} may match \cd{l\$name} silently!\\
\cd{[[} does NOT partial match: \cd{l[["na"]]}\ra \cd{NULL}.

\sub{On atomic vectors}
\cd{x[1]}\ra keeps names. \cd{x[[1]]}\ra drops names.\\
\cd{x[5]} (OOB)\ra \cd{NA}. \cd{x[[5]]} (OOB)\ra \textbf{ERROR}.

% ─────────────────────────────────────────────────
\sect{cgreen}{SUBSETTING MATRICES \& DATA FRAMES}
% ─────────────────────────────────────────────────

\sub{Matrices}
\cd{a[1:2,]}\ra rows 1--2. \cd{a[,c("B","A")]}\ra cols B, A.\\
Single row/col\ra \textbf{simplifies to vector}. Prevent: \cd{drop=FALSE}.\\
Stored in \textbf{column-major}: \cd{a[8]} = 8th element column-wise.\\
Matrix index: each row = coordinates. \cd{vals[select]}\ra vector.

\sub{Data frames}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\textbf{Syntax} & \textbf{Returns} & \textbf{Style}\\
\cd{df["x"]} & data.frame & list (preserves)\\
\rowcolor{cbg!40}\cd{df[,"x"]} & vector & matrix (simplifies)\\
\cd{df\$x} / \cd{df[["x"]]} & vector & list (simplifies)\\
\rowcolor{cbg!40}\cd{df[1,]} & data.frame row & matrix-style\\
\cd{df[c(1,3)]} & cols 1,3 (df) & list (no comma!)\\
\end{tabular}

\vspace{1pt}
\W \cd{mtcars[mtcars\$cyl<=5]}\ra \textbf{ERROR} (forgot comma --- selects cols!)\\
\textbf{Fix:} \cd{mtcars[mtcars\$cyl<=5, ]}\\
\W \cd{mtcars\$cyl==4|6}\ra always TRUE (\cd{6}\ra\cd{TRUE}).\\
\textbf{Fix:} \cd{cyl==4 | cyl==6} or \cd{cyl \%in\% c(4,6)}.\\
\W \cd{mtcars[1:13]}\ra ERROR (13 cols, only 11!). Fix: \cd{mtcars[1:13,]}.

\sub{Simplifying vs Preserving}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\textbf{Type} & \textbf{Preserving} & \textbf{Simplifying}\\
Atomic & \cd{x[1]} (names) & \cd{x[[1]]} (no names)\\
\rowcolor{cbg!40}List & \cd{x[1]} (list) & \cd{x[[1]]} (contents)\\
Factor & \cd{x[1]} (all lvls) & \cd{x[1,drop=T]}\\
\rowcolor{cbg!40}Matrix & \cd{a[1,,drop=F]} & \cd{a[1,]} (vector)\\
Data frame & \cd{df["x"]} (df) & \cd{df[,"x"]} (vector)\\
\end{tabular}

% ─────────────────────────────────────────────────
\sect{cgreen}{LOGICAL OPERATORS}
% ─────────────────────────────────────────────────

\sub{Vectorized vs Non-vectorized}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg}\textbf{Vectorized} & \textbf{Non-vectorized} & \textbf{Use in}\\
\cd{|} (OR), \cd{\&} (AND) & \cd{||}, \cd{\&\&} & \cd{if()} only\\
Returns \textbf{vector} & Returns \textbf{single} value & Length-1 req'd\\
\end{tabular}

\vspace{1pt}
\cd{||}/\cd{\&\&}: length$>$1\ra \textbf{ERROR} (R$\ge$4.3).

\sub{Short-circuit evaluation}
\cd{FALSE \&\& y}\ra \cd{FALSE} (y not evaluated).
\cd{TRUE || y}\ra \cd{TRUE} (y not evaluated).\\
\cd{FALSE || y}\ra evaluates y\ra error if length$>$1.
\cd{TRUE \&\& y}\ra same.

\sub{NA logic}
\begin{tabular}{@{}l|l|l@{}}
\rowcolor{cbg} & \cd{TRUE} & \cd{FALSE}\\
\cd{\_\_ | NA} & \cd{TRUE} & \cd{NA}\\
\rowcolor{cbg!40}\cd{\_\_ \& NA} & \cd{NA} & \cd{FALSE}\\
\end{tabular}

Rule: if result determined without NA, R returns it.\\
\cd{xor(T,T)}\ra\cd{F}. \cd{xor(T,F)}\ra\cd{T}. \cd{!NA}\ra\cd{NA}.\\
\cd{any(logical(0))}\ra\cd{FALSE}. \cd{all(logical(0))}\ra\cd{TRUE}.\\
\cd{"10" < "2"}\ra\cd{TRUE} (alphabetical!). \cd{"a" < "A"}\ra\cd{TRUE}.

\sub{Comparison operators}
\cd{==, !=, <, >, <=, >=} (vectorized, recycling).\\
\cd{\%in\%}: left-vectorized. \cd{c(1,2) \%in\% c(2,3)}\ra\cd{c(F,T)}.\\
\cd{is.\_\_\_()}: \cd{is.na}, \cd{is.null}, \cd{is.numeric}, \cd{is.character}, \cd{is.logical},
\cd{is.integer}, \cd{is.double}, \cd{is.list}, \cd{is.data.frame}, \cd{is.factor},
\cd{is.function}, \cd{is.matrix}, \cd{is.array}, \cd{is.atomic}.

% ─────────────────────────────────────────────────
\sect{cgreen}{CONTROL FLOW}
% ─────────────────────────────────────────────────

\sub{if() --- requires single non-NA logical}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Condition} & \textbf{Result}\\
Length $> 1$ & ERROR: ``condition has length $> 1$''\\
\rowcolor{cbg!40}\cd{NA} & ERROR: ``missing value where T/F needed''\\
Length 0 & ERROR: ``argument is of length zero''\\
\end{tabular}

\vspace{1pt}
\cd{else} \textbf{must} be on same line as closing \cd{\}}.\\
Once TRUE, remaining \cd{else if} blocks \textbf{skipped}.\\
\cd{ifelse(cond,yes,no)}\ra \textbf{vectorized}. Evaluates ALL branches.\\
\cd{case\_when(c1\~{}v1, c2\~{}v2, TRUE\~{}default)}: vectorized multi-cond.\\
Use \cd{any()}/\cd{all()} to reduce vector to single logical for \cd{if()}.

\sub{Loops}
\cd{for(x in vec)\{...\}}: iterates any vector/list.\\
\cd{while(cond)\{...\}}: after exit, counter one past end.\\
\cd{repeat\{...; if(...) break\}}: infinite until \cd{break}.\\
\cd{break}\ra exit loop. \cd{next}\ra skip to next iteration.\\
\cd{for(i in 1:10)\{if(i\%\%2==0) break; cat(i)\}}\ra prints \cd{1} only.\\
\cd{for(i in 1:10)\{if(i\%\%2==0) next; cat(i)\}}\ra \cd{1 3 5 7 9}.

\sub{Pre-allocate!}
\cd{res <- rep(NA, n)} then fill. NOT \cd{c(res,val)} (100x slower).\\
\W \cd{1:length(l)} when empty\ra \cd{c(1,0)} (loops twice!).\\
Fix: \cd{seq\_along(l)} or \cd{seq\_len(n)}\ra \cd{integer(0)} when empty.

\sub{Vectorization}
\cd{rowSums(x)/ncol(x)} much faster than loop + \cd{mean()}.\\
\cd{apply(x,1,mean)} slower than \cd{rowSums} approach.\\
\cd{colSums()}, \cd{colMeans()}, \cd{rowMeans()}\ra fast built-ins.\\
Vectorized ops avoid explicit loops and are 10--100x faster.

\sub{Operator precedence (high to low)}
\cd{\^{}} $>$ unary \cd{-/+} $>$ \cd{\%\%/\%/\%*\%/\%in\%} $>$ \cd{*/\!/} $>$ \cd{+/-} $>$ \cd{< > <= >= == !=} $>$ \cd{!} $>$ \cd{\&/\&\&} $>$ \cd{|/||} $>$ \cd{\~{}} $>$ \cd{-> ->>} $>$ \cd{<- <<-}\\
\W \cd{!x == y} means \cd{(!x) == y}, not \cd{!(x==y)}.\\
\cd{-2\^{}2}\ra \cd{-4} (power before negation!). \cd{(-2)\^{}2}\ra \cd{4}.\\
\cd{1:5 + 1}\ra \cd{c(2,3,4,5,6)} (\cd{:} binds tighter than \cd{+}).\\
\cd{1:(5+1)}\ra \cd{c(1,2,3,4,5,6)}.

\end{multicols}

% ═══════════════════════════════════════════════════
%  PAGE 2
% ═══════════════════════════════════════════════════

\newpage

\begin{multicols}{3}

% ─────────────────────────────────────────────────
\sect{cgreen}{FUNCTIONS}
% ─────────────────────────────────────────────────

\cd{name <- function(arg1, arg2=default) \{ body \}}\\
\cd{typeof(f)}\ra\cd{"closure"}. \cd{mode(f)}\ra\cd{"function"}.\\
\textbf{Implicit return:} last expression. \textbf{Explicit:} \cd{return()}.\\
Return multiple: \cd{list()}. One line: \cd{f <- function(x) x*x}.\\
\textbf{Arg matching:} 1) exact name, 2) positional.\\
\cd{f(y=2, 1, 3)}\ra y=2, then 1\ra x, 3\ra z (positional fill).\\
Missing used arg\ra ``arg missing, no default''. Extra\ra ``unused arg''.\\
Unused arg in body\ra \textbf{no error} (lazy evaluation).\\
\textbf{Scoping:} vars inside function are \textbf{local}. Must assign: \cd{x <- f(x)}.\\
\cd{rm(list=ls())} inside function only removes \textbf{local} objects.\\
\cd{...} (dots): passes extra args to inner functions.\\
\cd{f <- function(x, ...) plot(x, ...)}\ra forwards to \cd{plot()}.

% ─────────────────────────────────────────────────
\sect{cgreen}{USEFUL BASE R FUNCTIONS}
% ─────────────────────────────────────────────────

\sub{Searching \& matching}
\cd{which(x > 5)}\ra \textbf{indices} where TRUE. Ignores NA.\\
\cd{which.min(x)}, \cd{which.max(x)}\ra index of min/max.\\
\cd{match(x, table)}\ra 1st index of x in table (\cd{NA} if none).\\
\cd{match(c(3,5,1), c(1,2,3))}\ra \cd{c(3,NA,1)}.

\sub{Sequence \& repetition}
\cd{seq(from, to, by)} or \cd{seq(from, to, length.out=n)}.\\
\cd{seq\_along(x)}\ra safe \cd{1:length(x)}. \cd{seq\_len(n)}\ra safe \cd{1:n}.\\
\cd{rep(x, times=3)}\ra repeat whole 3x. \cd{rep(x, each=3)}\ra each 3x.\\
\cd{rep(c(1,2), times=c(3,2))}\ra \cd{c(1,1,1,2,2)}.

\sub{Sorting \& ordering}
\cd{sort(x)}\ra sorted values. \cd{rev(x)}\ra reversed.\\
\cd{order(x)}\ra indices that would sort. \cd{x[order(x)]}\ra \cd{sort(x)}.\\
\cd{df[order(df\$age),]}\ra sort df by age. \cd{order(x, decreasing=T)}.

\sub{Counting \& uniqueness}
\cd{table(x)}\ra freq table. \cd{table(x,y)}\ra cross-tab.\\
\cd{unique(x)}\ra unique values. \cd{duplicated(x)}\ra logical.\\
\cd{nrow()}, \cd{ncol()}, \cd{dim()}, \cd{str()}, \cd{summary()}, \cd{head()}, \cd{tail()}.

\sub{Apply family}
\cd{lapply(x, f)}\ra always returns \textbf{list}.\\
\cd{sapply(x, f)}\ra tries to simplify to vector/matrix.\\
\cd{vapply(x, f, FUN.VALUE)}\ra like sapply with type safety.\\
\cd{apply(M, 1, f)}\ra rows. \cd{apply(M, 2, f)}\ra cols.\\
\cd{tapply(x, group, f)}\ra by group. \cd{mapply(f, x, y)}\ra parallel.\\
\cd{do.call(f, list(a,b))}\ra same as \cd{f(a,b)}.\\
\W \cd{sapply} returns list OR vector (unpredictable). Use \cd{vapply}.

\sub{Missing data}
\cd{complete.cases(df)}\ra logical, rows with no NA.\\
\cd{na.omit(df)}\ra remove rows with any NA.\\
\cd{is.na(x) <- 3}\ra sets \cd{x[3]} to NA.

% ─────────────────────────────────────────────────
\sect{cteal}{ENVIRONMENTS \& SCOPING}
% ─────────────────────────────────────────────────

\textbf{Environment:} bag of name\ra value bindings. \textbf{Not ordered}.\\
\cd{e[[1]]}\ra ERROR. \cd{[} doesn't work (only \cd{[[} and \cd{\$}).\\
\cd{e\$d <- NULL} does NOT remove d. Use \cd{rm(d, envir=e)}.\\
\textbf{Copy-on-modify:} \cd{y<-x}; modify y copies, x unchanged.\\
\textbf{Name binding:} \cd{y<-x} binds to \textbf{same} object until modified.

\sub{4 special environments}
\cd{globalenv()}: user workspace. \cd{baseenv()}: base package.\\
\cd{emptyenv()}: ultimate ancestor (\textbf{no parent}).\\
\cd{search()}\ra search path. \cd{library()} inserts package.

\sub{Lexical scoping (KEY RULE)}
R looks where function was \textbf{DEFINED} (enclosing env),\\
\textbf{NOT} where it was \textbf{CALLED} (calling env).

\sub{4 function environments}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Type} & \textbf{What}\\
Enclosing & Where function was \textbf{created}\\
\rowcolor{cbg!40}Binding & Where function's \textbf{name} exists\\
Execution & \textbf{Temporary}, created per call\\
\rowcolor{cbg!40}Calling & Where function was \textbf{called from}\\
\end{tabular}

\vspace{1pt}
\cd{parent.frame()}\ra calling env (dynamic scoping).\\
\cd{get("y", envir=parent.frame())}\ra looks in calling env.

% ─────────────────────────────────────────────────
\sect{cteal}{SUPER ASSIGNMENT \& SCOPING EXAMPLES}
% ─────────────────────────────────────────────────

\cd{<<-} \textbf{never} creates in current env; modifies in parent.\\
Climbs scope; if not found, creates in global.\\
\W \textbf{Stops at FIRST scope where variable exists!}

\sub{Ex1: Nested (lexical scoping)}
\cd{x<-1; y<-1; z<-1}\\
\cd{f<-function()\{y<-2; g<-function()\{z<-3; x+y+z\}; g()\}}\\
\cd{f()}\ra \cd{6} ($x{=}1$ global, $y{=}2$ f, $z{=}3$ g). Global x,y,z still 1.

\sub{Ex2: Separate functions (KEY!)}
\cd{y<-10; g<-function()\{y\}; h<-function()\{y<-100; g()\}}\\
\cd{h()}\ra \cd{10} (g defined in global, finds global y=10).\\
\W g() finds \textbf{global} y, NOT h()'s local y=100.

\sub{Ex3: parent.frame()}
\cd{g<-function()\{get("y",envir=parent.frame())\}}\\
\cd{h<-function()\{y<-100; g()\}; h()}\ra \cd{100} (calling env).\\
\cd{g()}\ra \cd{10} (calling env is global).

\sub{Ex4: Super assignment}
\cd{x<-1; y<-1; z<-1}\\
\cd{f<-function()\{y<-2; y<<-4; g<-function()\{z<<-3; x+y+z\}; g()\}}\\
\cd{f()}\ra \cd{6}. Global: $y{=}4$, $z{=}3$. \cd{y<-2} local, \cd{y<<-4} global.

\sub{Ex5: <<- stops at first scope}
\cd{f<-function()\{y<-2; z<-10; y<<-4; g<-function()\{z<<-3; x+y+z\}; g()\}}\\
\cd{f()}\ra \cd{6}. Global $z{=}1$ unchanged! \cd{z<<-3} modifies f's z=10.

\sub{Danger of <<-}
\cd{foo\_bad<-function(foo,x)\{foo<<-c(foo,x\^{}2)\}; bar<-10; foo\_bad(bar,6)}\\
\cd{<<-} targets name ``foo'', not passed variable. bar unchanged!

% ─────────────────────────────────────────────────
\sect{corange}{DPLYR CORE VERBS}
% ─────────────────────────────────────────────────

All: 1st arg = df, return new df. Pipe: \cd{|>} (``then'').

\sub{select() --- choose columns}
\cd{select(df, name, age)}, \cd{select(df, -col)}, \cd{select(df, a:d)}.\\
Rename: \cd{select(df, new=old)}. Also: \cd{rename(df, new=old)}.\\
Helpers: \cd{starts\_with()}, \cd{ends\_with()}, \cd{contains()}, \cd{matches()},
\cd{everything()}, \cd{all\_of(v)}, \cd{any\_of(v)}, \cd{last\_col()}, \cd{where(is.numeric)}.

\sub{filter() --- keep rows}
\cd{filter(df, species == "Human")}. Comma = AND.\\
\cd{filter(df, x \%in\% c("a","b"))} for multiple values.\\
\W \cd{filter(df, species = "X")}\ra error (use \cd{==} not \cd{=}).\\
\W \cd{species=="A"|"B"}\ra all TRUE (\cd{"B"}\ra\cd{TRUE}).

\sub{mutate() --- add/transform columns}
Keeps all cols. Can reference just-created cols in same call.\\
\cd{.before = everything()} puts new cols first.\\
\cd{transmute()}\ra like mutate but drops original cols.

\sub{Other verbs}
\cd{arrange(df, desc(col))}\ra sort. \cd{slice(df, 5:10)}.\\
\cd{slice\_sample(n=5)}, \cd{slice\_max(col, n=3)}, \cd{slice\_min()}.\\
\cd{distinct(df, col1, .keep\_all=TRUE)}\ra unique rows.\\
\cd{pull(df, col)}\ra vector. \cd{relocate(df, col, .after=ref)}.\\
\cd{count(df, col)}\ra shortcut for \cd{group\_by + summarize(n=n())}.\\
\cd{if\_else(cond, T, F)}: strict types. \cd{case\_when(c\~{}v, TRUE\~{}d)}.

\sub{Useful mutate functions}
\cd{pmin()/pmax()}\ra row-wise min/max. \cd{coalesce()}\ra first non-NA.\\
\cd{cumsum()}, \cd{cummean()}. \cd{lead(x,n)/lag(x,n)}\ra shift.\\
\cd{between(x,a,b)}\ra $a \le x \le b$. \cd{ntile(x,n)}\ra n bins.\\
\cd{n()}\ra rows in group. \cd{n\_distinct(x)}\ra unique count.\\
\cd{row\_number()}, \cd{min\_rank()}, \cd{dense\_rank()}\ra ranking.

% ─────────────────────────────────────────────────
\sect{corange}{GROUP\_BY, SUMMARIZE, JOINS}
% ─────────────────────────────────────────────────

\cd{df |> summarize(m=mean(x, na.rm=T), cnt=n())}\\
\cd{df |> group\_by(sp) |> summarize(m=mean(ht))}\ra one row/group.\\
\cd{group\_by + mutate}\ra within-group (z-scores). \cd{ungroup()}.\\
Multiple: \cd{group\_by(a,b)}. Each summarize peels one layer.

\sub{Joins}
\begin{tabular}{@{}l|p{10.5em}@{}}
\rowcolor{cbg}\textbf{Join} & \textbf{Keeps}\\
\cd{left\_join(x,y)} & All x rows, match from y\\
\rowcolor{cbg!40}\cd{right\_join(x,y)} & All y rows, match from x\\
\cd{inner\_join(x,y)} & Only matching (intersection)\\
\rowcolor{cbg!40}\cd{full\_join(x,y)} & All rows from both (union)\\
\cd{semi\_join(x,y)} & x rows w/ match, no cols added\\
\rowcolor{cbg!40}\cd{anti\_join(x,y)} & x rows w/ \textbf{no} match\\
\end{tabular}

\vspace{1pt}
\cd{left\_join(x, y, by=join\_by(a == b))}. Same name: \cd{join\_by(x)}.\\
No match\ra \cd{NA}. Non-unique\ra \textbf{Cartesian product}.\\
Set ops: \cd{intersect()}, \cd{union()}, \cd{setdiff()} on rows.

% ─────────────────────────────────────────────────
\sect{corange}{TIDYR: RESHAPING}
% ─────────────────────────────────────────────────

\cd{pivot\_longer(df, cols=c1:c3, names\_to="year", values\_to="n")}\\
\cd{cols}: \cd{-country}, \cd{starts\_with("20")}, \cd{2:4}. Unpivoted cols duplicated.\\
\cd{pivot\_wider(df, id\_cols=city, names\_from=sz, values\_from=amt)}\\
\cd{values\_fill=0}. \W ``NYC'' vs ``New York''\ra separate rows!\\
They are \textbf{inverse} operations. \cd{separate()}/\cd{unite()} for string cols.

% ─────────────────────────────────────────────────
\sect{cpurple}{STRINGS \& REGEX}
% ─────────────────────────────────────────────────

\cd{paste("a",1:3,sep="")}\ra \cd{c("a1","a2","a3")}. \cd{paste0}=\cd{sep=""}.\\
\cd{collapse=","}\ra \cd{"a1,a2,a3"} (single string).\\
\cd{cat()}\ra prints w/o quotes, returns \cd{invisible(NULL)}.\\
\cd{nchar("hi")}\ra 2. \cd{substr("hello",2,4)}\ra \cd{"ell"}.\\
\cd{sprintf("\%d items at \$\%.2f", 3, 9.5)}\ra \cd{"3 items at \$9.50"}.

\sub{stringr functions}
\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Function} & \textbf{Returns}\\
\cd{str\_detect(s,p)} & logical vector\\
\rowcolor{cbg!40}\cd{str\_extract(s,p)} & matched text or NA\\
\cd{str\_match(s,p)} & matrix: full + groups\\
\rowcolor{cbg!40}\cd{str\_replace(s,p,r)} & 1st match replaced\\
\cd{str\_split(s,p)} & list of pieces\\
\rowcolor{cbg!40}\cd{str\_count/locate/sub} & count / position / substring\\
\end{tabular}

\cd{\_all} suffix: ALL matches. \cd{str\_extract\_all}\ra \textbf{list}.

\sub{Regex metacharacters (escape: \texttt{\textbackslash\textbackslash})}
\cd{.}\ra any char. \cd{[\^{}aeiou]}\ra negation. \cd{\textbackslash\textbackslash d}/\cd{\textbackslash\textbackslash w}/\cd{\textbackslash\textbackslash s}\ra digit/word/space.\\
\cd{\^{}}\ra start. \cd{\$}\ra end. \cd{\textbackslash\textbackslash b}\ra word boundary.\\
Caret 3 meanings: \cd{\^{}[0-9]} start; \cd{[\^{}0-9]} negate; \cd{[0-9\^{}]} literal.\\
Inside \cd{[]}: most metachar literal. Exceptions: \cd{] - \^{} \textbackslash}.

\sub{Quantifiers \& Greedy/Lazy}
\cd{*} 0+, \cd{+} 1+, \cd{?} 0/1, \cd{\{n\}}, \cd{\{n,\}}, \cd{\{n,m\}}.\\
\textbf{Greedy} (default): longest. Add \cd{?} for \textbf{lazy} (shortest).\\
\cd{str\_extract("Peter Piper","P.*r")}\ra \cd{"Peter Piper"} (greedy).\\
\cd{str\_extract("Peter Piper","P.*?r")}\ra \cd{"Peter"} (lazy).

\sub{Groups \& Backreferences}
\cd{(abc)}\ra capture. \cd{(?:abc)}\ra non-capture. \cd{|}\ra alternation.\\
\W Order matters: \cd{(Mr|Mrs)} on ``Mrs.''\ra \cd{"Mr"} (first wins!).\\
\cd{\textbackslash\textbackslash 1}/\cd{\textbackslash\textbackslash 2} in replacement reference groups.\\
\cd{str\_match}\ra matrix: col1=full, col2+=groups.

\sub{Lookarounds (zero-width, not consumed)}
\cd{(?=...)}\ra pos ahead. \cd{(?!...)}\ra neg ahead.\\
\cd{(?<=...)}\ra pos behind. \cd{(?<!...)}\ra neg behind.\\
Lookbehind: \textbf{bounded length only} (no \cd{*}/\cd{+}).

% ─────────────────────────────────────────────────
\sect{cred}{S3 OOP}
% ─────────────────────────────────────────────────

\textbf{Generic function OOP}: methods belong to \textbf{functions}.\\
Generic calls \cd{UseMethod("name")}. Methods: \cd{generic.class()}.\\
Create: \cd{structure(list(), class="fruit")} or \cd{class(y)<-"fruit"}.\\
No formal definition; just set class attr. Class can be vector.\\
\W Use \cd{inherits(x,"fruit")} not \cd{class(x)=="fruit"}.

\sub{Dispatch order}
\cd{UseMethod}: \cd{gen.class1}\ra\cd{gen.class2}\ra...\ra\cd{gen.default}.\\
No match + no default\ra ERROR. Direct \cd{f.j(x)} bypasses dispatch.\\
\cd{class(k)<-NULL}\ra implicit class (double/numeric then default).

\sub{Dispatch examples}
\cd{f<-function(x) UseMethod("f"); f.j<-function(x) x+2; f.k<-function(x) x+10}\\
\cd{k<-1; f(k)}\ra \textbf{ERROR} (no f.double/f.numeric/f.default).\\
\cd{class(k)<-"j"; f(k)}\ra 3. Add \cd{f.default<-function(x) x+100}.\\
\cd{structure(10,class=c("k","l"))}\ra f.k first. \cd{c("m","n")}\ra f.default.\\
\cd{f(7)}\ra 107 (double). \cd{f.j(7)}\ra 9 (direct, bypasses dispatch).\\
\W \cd{7} is double; \cd{7L} is integer! \cd{f.integer<-function(x) 100*x}\\
\cd{f(7)}\ra 107 (double!). \cd{f(7L)}\ra 700 (integer!).

\sub{UseMethod mismatch}
\cd{f<-function(x) UseMethod("g")}\ra dispatches \cd{g.class} not \cd{f.class}!

% ─────────────────────────────────────────────────
\sect{cred}{R6 OOP}
% ─────────────────────────────────────────────────

\textbf{Encapsulated OOP}: methods belong to \textbf{objects}. \cd{library(R6)}.\\
\cd{Cls <- R6Class("Cls", public=list(val=0, set=function(x)\{}\\
\cd{\ \ self\$val<-x; invisible(self)\}))}. Instance: \cd{x <- Cls\$new()}.\\
\cd{self\$}\ra own fields. \cd{invisible(self)}\ra method chaining.\\
\cd{\$initialize()}\ra overrides \cd{\$new()}. \cd{\$print()}\ra custom print.\\
Methods bound at creation; redefining class won't update old objects.\\
\cd{\$set("public","field",val)}\ra add after creation (new objs only).

\sub{Inheritance \& Reference semantics}
\cd{R6Class("Child", inherit=Parent)}. \cd{super\$method()} for parent.\\
\cd{class(x)}\ra \cd{c("Child","Parent","R6")}.\\
\cd{y <- x}\ra \textbf{SAME object}! \cd{y\$set(10)} changes x too!\\
\cd{y <- x\$clone()}\ra independent. \cd{\$clone(deep=TRUE)}\ra deep copy.\\
Functions can modify R6 args without assignment: \cd{f(x)} changes x!

% ─────────────────────────────────────────────────
\sect{cred}{COMMON TRAPS --- QUICK REFERENCE}
% ─────────────────────────────────────────────────

\begin{tabular}{@{}l|l@{}}
\rowcolor{cbg}\textbf{Trap} & \textbf{Reality}\\
\cd{typeof(df)} & \cd{"list"} not \cd{"data.frame"}\\
\rowcolor{cbg!40}\cd{typeof(factor)} & \cd{"integer"} not \cd{"factor"}\\
\cd{7} vs \cd{7L} & double vs integer (S3 dispatch!)\\
\rowcolor{cbg!40}\cd{1:0} & \cd{c(1,0)} not empty! Use \cd{seq\_len}\\
\cd{c(1,NULL,3)} & \cd{c(1,3)} (NULL dropped)\\
\rowcolor{cbg!40}\cd{NA == NA} & \cd{NA} (use \cd{is.na()})\\
\cd{NA * 0} & \cd{NA} (not 0!)\\
\rowcolor{cbg!40}Matrix fill & Column-wise (not row-wise)\\
\cd{as.numeric(factor)} & Gives indices, not values\\
\rowcolor{cbg!40}\cd{x[2.9]} & Same as \cd{x[2]} (truncated)\\
\cd{<<-} & Stops at first scope w/ var\\
\rowcolor{cbg!40}R6 \cd{y<-x} & Shared ref (use \cd{\$clone()})\\
Greedy regex & Longest; \cd{?} for shortest\\
\rowcolor{cbg!40}\cd{[} on list & Always returns list\\
\cd{if(vec)} & ERROR if length$>$1\\
\rowcolor{cbg!40}\cd{f.j(7)} & Bypasses S3 dispatch\\
\cd{UseMethod("g")} & Dispatches \cd{g.class} not \cd{f.class}\\
\rowcolor{cbg!40}\cd{df[1:13]} no comma & Selects columns, not rows!\\
\cd{as.logical("t"/"1")} & \cd{NA} (only full words)\\
\rowcolor{cbg!40}\cd{as.logical(c("0",1))} & All \cd{NA} (char coercion first)\\
\cd{factor} bad assign & \cd{NA} with warning\\
\rowcolor{cbg!40}\cd{"10" < "2"} & \cd{TRUE} (alphabetical!)\\
\cd{any(logical(0))} & \cd{FALSE}\\
\rowcolor{cbg!40}\cd{all(logical(0))} & \cd{TRUE}\\
\cd{(Mr|Mrs)} & \cd{"Mr"} first wins on ``Mrs''\\
\rowcolor{cbg!40}\cd{round(2.5)} & \cd{2} (banker's rounding)\\
\cd{is.numeric(1L)} & \cd{TRUE} (int IS numeric)\\
\rowcolor{cbg!40}\cd{identical(1, 1L)} & \cd{FALSE} (type matters)\\
\cd{sapply} empty & Returns \cd{list()} not vector\\
\rowcolor{cbg!40}\cd{l\$na} & Partial match\ra wrong result\\
\cd{f(x=3)} vs \cd{f(x<-3)} & \cd{=} arg only; \cd{<-} also assigns\\
\rowcolor{cbg!40}\cd{Inf - Inf} & \cd{NaN} (not 0)\\
\cd{(-7) \%\% 3} & \cd{2} (R modulo always $\ge 0$)\\
\rowcolor{cbg!40}\cd{nchar(NA)} & \cd{NA} (not 2!)\\
\cd{NULL + 1} & \cd{numeric(0)} (not error)\\
\cd{log(0)} & \cd{-Inf} (not error)\\
\rowcolor{cbg!40}\cd{Inf * 0} & \cd{NaN} (not 0)\\
\cd{is.na(NaN)} & \cd{TRUE} (NaN is NA!)\\
\rowcolor{cbg!40}\cd{NULL == NULL} & \cd{logical(0)} (not TRUE)\\
\cd{e\$d <- NULL} in env & Does NOT remove d\\
\rowcolor{cbg!40}\cd{for(i in 1:0)} & Loops \textbf{twice} (1,0)\\
\end{tabular}

\vspace{2pt}
\sect{cred}{ERROR HANDLING}

\cd{stop("msg")}\ra raises error. \cd{warning("msg")}\ra warning.\\
\cd{message("msg")}\ra message (to stderr).\\
\cd{tryCatch(expr, error=function(e) ..., warning=function(w) ...)}.\\
\cd{try(expr)}\ra returns result or \cd{try-error} object (no stop).\\
\cd{stopifnot(x > 0)}\ra stops if condition FALSE.\\
\cd{suppressWarnings(expr)}, \cd{suppressMessages(expr)}.

\vspace{2pt}
\sect{cred}{MISC R TRICKS}

\cd{switch(x, "a"=1, "b"=2, 3)}\ra match x; last = default.\\
\cd{Sys.time()}\ra current datetime. \cd{proc.time()}\ra CPU time.\\
\cd{system.time(expr)}\ra time an expression.\\
\cd{sample(1:10, 5)}\ra 5 random from 1:10 (no replace).\\
\cd{sample(1:10, 5, replace=TRUE)}\ra with replacement.\\
\cd{set.seed(42)}\ra reproducible randomness.\\
\cd{print(x)} returns x invisibly. \cd{cat()} returns \cd{invisible(NULL)}.\\
\cd{invisible(x)}\ra return x without printing.\\
\cd{exists("x")}\ra TRUE if x exists in scope.\\
\cd{get("x")}\ra get value by name string. \cd{assign("x", 5)}\ra set.\\
\cd{nargs()}\ra number of args passed to current function.\\
\cd{missing(x)}\ra TRUE if arg x was not supplied.\\
\cd{is.function(mean)}\ra TRUE. \cd{is.primitive(sum)}\ra TRUE.\\
\cd{environment(f)}\ra enclosing env of f. \cd{body(f)}\ra function body.\\
\cd{formals(f)}\ra list of formal arguments with defaults.\\
\cd{methods("print")}\ra all print methods. \cd{methods(class="factor")}.\\
\cd{paste(1:3, collapse="+")}\ra \cd{"1+2+3"}.\\
\cd{strsplit("a.b.c", "\\\\.")}\ra \cd{list(c("a","b","c"))}.\\
\cd{gsub("old","new",x)}\ra replace all in base R.\\
\cd{sub("old","new",x)}\ra replace first in base R.\\
\cd{grepl("pattern",x)}\ra logical (base R \cd{str\_detect}).\\
\cd{grep("pattern",x)}\ra indices of matches.\\
\cd{regmatches(x, regexpr(p, x))}\ra base R extract.\\
\cd{trimws(" hi ")}\ra \cd{"hi"} (trim whitespace).\\
\cd{startsWith("abc","ab")}\ra TRUE. \cd{endsWith("abc","bc")}\ra TRUE.\\
\cd{sprintf("\%05d", 42)}\ra \cd{"00042"} (zero-padded).\\
\cd{sprintf("\%.1e", 1234)}\ra \cd{"1.2e+03"} (scientific).

\end{multicols}
\end{document}
